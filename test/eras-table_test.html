<!doctype html>
<html lang='en'>

<head>
	<meta charset='utf-8'>
	<meta name='viewport' content='width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes'>

	<title>eras-table test</title>

	<script src='../../webcomponentsjs/webcomponents-lite.js'></script>
	<script src='../../web-component-tester/browser.js'></script>

	<link rel='import' href='../eras-table-display.html'>
	<link rel='import' href='../eras-table-sort-switch.html'>
	<link rel='import' href='../eras-table-sort-popup.html'>
</head>

<body>

	<test-fixture id="sort-switch-fixture">
		<template>
			<eras-table-sort-switch id='sort-switch' direction='asc'></eras-table-sort-switch>
		</template>
	</test-fixture>
	<script>
		suite('eras-table-sort-switch', function () {
			var el;
			setup(function () {
				el = fixture('sort-switch-fixture');
			});
			test('instantiation', function (done) {
				assert.equal(el.is, 'eras-table-sort-switch');
				done();
			});
			test('click', function (done) {
				el.direction = 'asc';
				el.click();
				assert.equal('desc', el.direction, 'expected `direction` to have changed to "desc" but it is ' + el.direction);
				done();
			});
			test('value', function (done) {
				// temporarily disable console.warn so the message about invalid values
				// doesn't show up in the console (test failures are errors so should be OK)
				var w = console.warn;
				console.warn = function () { };
				el.direction = 'xxx';
				console.warn = w;
				assert.equal(el.direction, 'asc', 'expected invalid value to default to "asc" but it didn\'t');
				done();
			});
		});
	</script>

	<template is='dom-bind' id='sort-template'>
		<eras-table-sort-popup id='sort-popup'></eras-table-sort-popup>
		<!-- <eras-table-column property='prop-1' label='Column 1' can-sort></eras-table-column>
		<eras-table-column property='prop-2' label='Column 2'></eras-table-column>
		<eras-table-column property='prop-3' label='Column 3' can-sort></eras-table-column> -->
	</template>
	<script>
		var sortApp = document.querySelector('#sort-template');

		suite('eras-table-sort-popup', function () {
			var el;
			var columns;
			var spyFire;
			var spyAdd;
			var spyUpdate;
			var spyRemove;

			setup(function () {
				el = document.querySelector('#sort-popup');
				columns = [];
				spyFire = sinon.spy(el, 'fire');
				spyAdd = sinon.spy(el, '_add');
				spyUpdate = sinon.spy(el, '_update');
				spyRemove = sinon.spy(el, '_remove');


				for (var i = 1; i <= 5; i++) {
					var col = document.createElement('eras-table-column');
					col.canSort = i < 4;
					col.property = 'property-' + i;
					col.label = 'Column ' + i;
					columns.push(col);
				}

				el.columns = columns;
				el._options = [];
				el._direction = 'asc';
				el._property = null;
				el.sort = [];
			});

			teardown(function () {
				el.fire.restore();
				el._add.restore();
				el._update.restore();
				el._remove.restore();
			});

			test('instantiation', function (done) {
				assert.equal(el.is, 'eras-table-sort-popup');
				done();
			});

			test('columns', function (done) {
				assert.equal(5, el.columns.length);
				done();
			});

			test('open/close', function (done) {
				el.open();
				assert(spyFire.withArgs('iron-overlay-opened'.calledOnce), 'expected `iron-overlay-opened` to have been fired once');
				el._close();
				assert(spyFire.withArgs('iron-overlay-closed'.calledOnce), 'expected `iron-overlay-closed` to have been fired once');
				done();
			});

			test('options filter', function (done) {
				el.open();
				assert.equal(3, el._options.length, 'expected only 3 sortable options, got ' + el._options.length);
				el._close();
				done();
			});

			suite('select', function () {
				var selectTest = function (index) {
					return function (done) {
						var prop = columns[index].property;
						flush(function () {
							el.open();
							el.$.optionsMenu.click();
							flush(function () {
								el.$.optionsMenu.querySelector('paper-item[value="' + prop + '"]').click();
								assert.equal(prop, el._property, 'expected `' + prop + '` to be selected not `' + el._property + '`');
								el._close();
								done();
							});
						});
					}
				}

				for (var i = 0; i < 3; i++)
					test('column ' + (i + 1), selectTest(i));
			});

			test('direction switch', function (done) {
				flush(function () {
					el.open();
					assert.equal('asc', el._direction, 'expected `asc` before interaction, not `' + el._direction + '`');
					el.$.directionSwitch.click();
					assert.equal('desc', el._direction, 'expected `desc` after first click, not `' + el._direction + '`');
					el.$.directionSwitch.click();
					assert.equal('asc', el._direction, 'expected `asc` after second click, not `' + el._direction + '`');
					el._close();
					done();
				});
			});

			suite('add', function () {
				var addTest = function (index) {
					return function (done) {
						var prop = columns[index].property;
						flush(function () {
							el.open();
							el._property = prop;
							el._direction = 'desc';
							el.$.addButton.click();
							assert(spyAdd.calledOnce, 'expected `_add` to be called once');
							assert.equal(1, el._newSort.length, 'expected 1 sort criteria not ' + el._newSort.length);
							el._close();
							done();
						});
					}
				}

				for (var i = 0; i < 3; i++)
					test('column ' + (i + 1), addTest(i));
			});

			test('update', function (done) {
				flush(function () {
					el.open();
					el._newSort = [
						{ property: columns[0].property, direction: 'asc' },
						{ property: columns[2].property, direction: 'desc' },
					];
					el.$$('.buttons>paper-icon-button[dialog-confirm]').click();

					assert(spyUpdate.calledOnce, 'expected `_update` to be called once');
					assert.equal(2, el.sort.length, 'expected 2 sort criteria not ' + el.sort.length);
					done();
				});
			});

			test('remove', function (done) {
				flush(function () {
					el.open();
					el._newSort = [
						{ property: columns[0].property, direction: 'asc' },
						{ property: columns[1].property, direction: 'asc' },
						{ property: columns[2].property, direction: 'desc' },
					];

					for (var i = 0; i < 3; i++) {
						el.$$('paper-item.sort-item paper-icon-button.remove').click();
						var expected = 3 - (i + 1);
						assert.equal(expected, el._newSort.length, 'expected ' + expected + ' criteria to be removed after ' + (i + 1) + 'clicks,  but found ' + el._newSort.length);
					}

					assert(spyRemove.calledThrice, 'expected `_remove` to be called 3x');
					assert.equal(0, el._newSort.length, 'expected all criteria to be removed but found ' + el._newSort.length);

					el._close();
					done();
				});
			});
		});
	</script>

	<template is='dom-bind' id='basic-template'>
		<eras-table-display id='basic-table' data='{{data}}' page='{{page}}' id-property='prop-1'>
			<eras-table-column property='prop-1' label='Column 1'></eras-table-column>
			<eras-table-column property='prop-2' label='Column 2'></eras-table-column>
			<eras-table-column property='prop-3' label='Column 3'></eras-table-column>
		</eras-table-display>
	</template>
	<script>
		var basicApp = document.querySelector('#basic-template');
		basicApp.data = [];

		for (var row = 0; row < 3; row++) {
			basicApp.data[row] = {};
			for (var col = 1; col <= 3; col++) {
				basicApp.data[row]['prop-' + col] = 'data-' + row + '-prop-' + col;
			}
		}

		basicApp.page = { current: 1, size: 5, results: 12 };
	</script>

	<template is='dom-bind' id='selection-template'>
		<eras-table-display id='selection-table' data='{{data}}' page='{{page}}' select='none' id-property='prop-1' selected-ids='{{selectedIds}}'>
			<eras-table-column property='prop-1' label='Column 1'></eras-table-column>
			<eras-table-column property='prop-2' label='Column 2'></eras-table-column>
			<eras-table-column property='prop-3' label='Column 3'></eras-table-column>
		</eras-table-display>
	</template>
	<script>
		var selectionApp = document.querySelector('#selection-template');
		selectionApp.data = [];

		for (var row = 0; row < 5; row++) {
			selectionApp.data[row] = {};
			for (var col = 1; col <= 3; col++) {
				selectionApp.data[row]['prop-' + col] = 'data-' + row + '-prop-' + col;
			}
		}

		selectionApp.page = { current: 1, size: 5, results: 12 };
		selectionApp.selectedIds = ['data-1-prop-1', 'data-3-prop-1'];
	</script>

	<script>
		suite('eras-table-display', function () {
			suite('basic', function () {
				var el;

				setup(function () {
					el = document.querySelector('#basic-table');
				});

				test('instantiation', function (done) {
					assert.equal(el.is, 'eras-table-display');
					done();
				});

				test('select type', function (done) {
					// temporarily disable console.warn so the message about invalid values
					// doesn't show up in the console (test failures are errors so should be OK)
					var w = console.warn;
					console.warn = function () { };
					el.select = 'xxx';
					console.warn = w;
					assert.equal(el.select, 'none', 'expected invalid value to default to "none" but it didn\'t');
					done();
				});

				test('columns', function (done) {
					flush(function () {
						var cols = el.$.head.querySelectorAll('div.cell.head.label');
						assert.equal(el.columns.length, 3, 'table.columns should have 3 objects but has ' + el.columns.length);
						assert.equal(cols.length, 3, 'the table should have 3 column labels (th.label) but has ' + cols.length);
						done();
					});
				});

				test('rows', function (done) {
					flush(function () {
						var rows = el.$.body.querySelectorAll('div.row.data');
						assert.equal(el.data.length, 3, 'table.data should have 3 objects but has ' + el.data.length);
						assert.equal(rows.length, 3, 'the table should have 3 data rows (tr.data) but has ' + rows.length);
						done();
					});
				});

				test('get data', function (done) {
					flush(function () {
						var col = el.columns[1];
						var row = el.data[2];
						var x = el.getData(col, row);
						assert.equal(x, 'data-2-prop-2');
						done();
					});
				});

				suite('paging buttons', function () {
					var lastPage;
					var params = [];

					params[0] = { page: 1, buttons: [] };
					params[0].buttons[0] = { id: 'first', index: 0, target: 1, enabled: false };
					params[0].buttons[1] = { id: 'previous', index: 1, target: 1, enabled: false };
					params[0].buttons[2] = { id: 'next', index: 2, target: 2, enabled: true };
					params[0].buttons[3] = { id: 'last', index: 3, target: 3, enabled: true };

					params[1] = { page: 2, buttons: [] };
					params[1].buttons[0] = { id: 'first', index: 0, target: 1, enabled: true };
					params[1].buttons[1] = { id: 'previous', index: 1, target: 1, enabled: true };
					params[1].buttons[2] = { id: 'next', index: 2, target: 3, enabled: true };
					params[1].buttons[3] = { id: 'last', index: 3, target: 3, enabled: true };

					params[2] = { page: 3, buttons: [] };
					params[2].buttons[0] = { id: 'first', index: 0, target: 1, enabled: true };
					params[2].buttons[1] = { id: 'previous', index: 1, target: 2, enabled: true };
					params[2].buttons[2] = { id: 'next', index: 2, target: 3, enabled: false };
					params[2].buttons[3] = { id: 'last', index: 3, target: 3, enabled: false };

					setup(function () {
						lastPage = Math.ceil(el.page.results / el.page.size);
					});

					suite('objects', function () {
						for (var p = 0; p < params.length; p++) {
							var param = params[p];

							for (var b = 0; b < param.buttons.length; b++) {
								var button = param.buttons[b];

								test('page ' + param.page + ': ' + button.id, function (done) {
									el.page = { current: param.page, size: el.page.size, results: el.page.results };
									flush(function () {
										var buttonElement = el._pagingButtons[button.index];
										assert.equal(buttonElement.target, button.target, 'on page ' + param.page + ' ' + button.id + '.target should be ' + button.target);
										assert.equal(buttonElement.enabled, button.enabled, 'on page ' + param.page + ' ' + button.id + '.enabled should be ' + button.enabled);
										done();
									});
								});
							}
						}
					});

					suite('elements', function () {
						for (var p = 0; p < params.length; p++) {
							var param = params[p];

							for (var b = 0; b < param.buttons.length; b++) {
								var button = param.buttons[b];

								test('page ' + param.page + ': ' + button.id, function (done) {
									el.page = { current: param.page, size: el.page.size, results: el.page.results };
									flush(function () {
										var buttonElement = el.$$('#' + button.id);
										assert.equal(buttonElement.dataTargetPage, button.target, 'on page ' + param.page + ' ' + button.id + '.dataTargetPage should be ' + button.target);
										assert.equal(buttonElement.disabled, !button.enabled, 'on page ' + param.page + ' ' + button.id + '.disabled should be ' + (!button.enabled));
										done();
									});
								});
							}
						}
					});

					suite('events', function () {
						var spy;

						setup(function () {
							spy = sinon.spy(el, 'fire');
						});

						teardown(function () {
							el.fire.restore();
						});

						for (var p = 0; p < params.length; p++) {
							var param = params[p];

							for (var b = 0; b < param.buttons.length; b++) {
								var button = param.buttons[b];

								test('page ' + param.page + ': ' + button.id, function (done) {
									el.page = { current: param.page, size: el.page.size, results: el.page.results };
									flush(function () {
										el.$$('#' + button.id).click();

										if (button.enabled) {
											assert(spy.withArgs('change-page').calledOnce, 'change-page event should have fired once');
											assert(spy.withArgs('change-page', { target: button.target }).calledOnce, 'change-page event fired but with wrong args: ' + JSON.stringify(spy.args));
										} else {
											assert(spy.withArgs('change-page').notCalled, 'change-page event should not have fired');
										}
										done();
									});
								});
							}
						}
					});
				});

				suite('page size', function () {
					var menu;

					setup(function () {
						menu = el.$.perPageMenu;
					});

					test('setup', function (done) {
						flush(function () {
							assert.equal(menu.is, 'paper-dropdown-menu');
							done();
						});
					});

					var params = [];
					params[0] = { results: 0, options: [] };
					params[1] = { results: 3, options: [3] };
					params[2] = { results: 5, options: [5] };
					params[3] = { results: 6, options: [5, 6] };
					params[4] = { results: 11, options: [5, 10, 11] };
					params[5] = { results: 25, options: [5, 10, 25] };
					params[6] = { results: 100, options: [5, 10, 25, 50, 100] };
					params[7] = { results: 101, options: [5, 10, 25, 50, 100, 101] };
					params[8] = { results: 9999, options: [5, 10, 25, 50, 100, 9999] };

					suite('objects', function () {
						for (var i = 0; i < params.length; i++) {
							var p = params[i];

							test('with ' + p.results + ' results', function (done) {
								el.page = { current: el.page.current, size: el.page.current, results: p.results };
								flush(function () {
									var biggest = Math.max.apply(null, el._pageSizeOptions);
									assert.equal(biggest, p.results, 'expected the biggest page size (' + biggest + ') to == the number of results (' + el.page.results + ')');
									assert.deepEqual(el._pageSizeOptions, p.options, 'expected ' + p.options + ' options for page size but there were ' + el._pageSizeOptions)
									done();
								});
							});
						}
					});

					suite('elements', function () {
						for (var i = 0; i < params.length; i++) {
							var p = params[i];

							test('with ' + p.results + ' results', function (done) {
								el.page = { current: el.page.current, size: el.page.current, results: p.results };
								flush(function () {
									// get list of page size options from value attr of paper-item elements
									var elements = menu.querySelectorAll('paper-item');
									var options = [];
									for (var j = 0; j < elements.length; j++)
										options[j] = elements[j].value;

									var biggest = Math.max.apply(null, options);
									assert.equal(biggest, p.results, 'expected the biggest page size (' + biggest + ') to == the number of results (' + el.page.results + ')');
									assert.deepEqual(options, p.options, 'expected ' + p.options + ' options for page size but there were ' + options)
									done();
								});
							});
						}
					});

					suite('events', function () {
						var spy;
						var options = [5, 10, 25, 30];

						suiteSetup(function () {
							el.page = { current: el.page.current, size: el.page.current, results: Math.max.apply(null, options) };
						});

						setup(function () {
							spy = sinon.spy(el, 'fire');
						});

						teardown(function () {
							el.fire.restore();
						});

						// this method of looping tests was inspired by this answer:
						// https://stackoverflow.com/a/17316273/723645 
						var dataTest = function (index, option) {
							return function (done) {
								flush(function () {
									var button = menu.querySelectorAll("paper-item")[index];
									button.click();
									assert(spy.withArgs('per-page-change').calledOnce, 'per-page-change event should have fired once');
									assert(spy.withArgs('per-page-change', { size: option }).calledOnce, 'per-page-change event fired but with wrong args: ' + JSON.stringify(spy.args));
									done();
								});
							};
						};

						for (var i = 0; i < options.length; i++) {
							var option = options[i];
							test(option + ' per page', dataTest(i, option));
						}
					});
				});
			});

			suite('selection', function () {
				var el;
				var visibleIds;
				var spy;

				// either select or deselect all check boxes to start
				function setupSelection(selected, visibleIds) {
					el._listenForMultiSelect = false;
					el._listenForSingleSelect = false;

					var all = el.querySelectorAll('div.cell.selector paper-checkbox');
					for (var i = 0; i < all.length; i++) {
						if (selected)
							Polymer.dom(all[i]).setAttribute('checked', '');
						else
							Polymer.dom(all[i]).removeAttribute('checked');
					}

					if (selected)
						el.selectedIds = visibleIds;
					else
						el.selectedIds = [];

					el._listenForMultiSelect = true;
					el._listenForSingleSelect = true;
				}

				setup(function () {
					el = document.querySelector('#selection-table');
					visibleIds = el.data.map(function (d) { return d[el.idProperty]; });
					spy = sinon.spy(el, 'fire');
				});

				teardown(function () {
					el.fire.restore();
				});

				test('instantiation', function (done) {
					assert.equal(el.is, 'eras-table-display');
					done();
				});

				suite('pre selection', function () {
					test('array length', function (done) {
						assert.equal(2, el.selectedIds.length, 'expected 2 ids in array but found ' + el.selectedIds.length);
						done();
					});

					test('checkboxes', function (done) {
						flush(function () {
							var checkboxes = el.$.body.querySelectorAll('paper-checkbox[checked]');
							assert.equal(2, checkboxes.length, 'expected 2 of the checkboxes to be checked but found ' + checkboxes.length);
							done();
						});
					});
				});

				suite('multi selection', function () {
					var multi;

					setup(function () {
						el.select = 'multi';
						multi = el.$.head.querySelector('.multi-selector paper-checkbox');
					});

					test('select all', function (done) {
						setupSelection(false, visibleIds);

						multi.click();

						var checkboxes = el.$.body.querySelectorAll('paper-checkbox[checked]');
						assert(spy.withArgs('selection-change').calledOnce, 'selection-change should have been fired once');
						assert.equal(el.data.length, checkboxes.length, 'expected all ' + el.data.length + ' of the checkboxes to be checked but found ' + checkboxes.length);
						assert(visibleIds.every(function (e) { return el.selectedIds.indexOf(e) >= 0; }), 'expected ids for all visible rows (' + visibleIds + ') to be in selectedIds (' + el.selectedIds + ')');
						assert.equal(el.data.length, selectionApp.selectedIds.length, 'two way data binding not working, expected ' + el.data.length + ' but got ' + selectionApp.data.length);
						done();
					});

					test('deselect all', function (done) {
						setupSelection(true, visibleIds);

						multi.click();

						var checkboxes = el.$.body.querySelectorAll('paper-checkbox[checked]');
						assert(spy.withArgs('selection-change').calledOnce, 'selection-change should have been fired once');
						assert.equal(0, checkboxes.length, 'expected none of the checkboxes to be checked but found ' + checkboxes.length);
						assert(visibleIds.every(function (e) { return el.selectedIds.indexOf(e) < 0; }), 'expected no ids for visible rows (' + visibleIds + ') to be in selectedIds (' + el.selectedIds + ')');
						assert.equal(0, selectionApp.selectedIds.length, 'two way data binding not working, expected 0 but got ' + selectionApp.data.length);
						done();
					});

					test('select one at a time', function (done) {
						setupSelection(false, visibleIds);

						var checkboxes = el.$.body.querySelectorAll('paper-checkbox');
						for (var i = 0; i < checkboxes.length; i++)
							checkboxes[i].click();

						var selected = el.$.body.querySelectorAll('paper-checkbox[checked]');
						assert.equal(el.data.length, spy.withArgs('selection-change').callCount, 'selection-change should have been fired ' + el.data.length + 'times');
						assert.equal(el.data.length, selected.length, 'expected all ' + el.data.length + ' of the checkboxes to be checked but found ' + selected.length);
						assert(visibleIds.every(function (e) { return el.selectedIds.indexOf(e) >= 0; }), 'expected ids for all visible rows (' + visibleIds + ') to be in selectedIds (' + el.selectedIds + ')');
						assert.equal(el.data.length, selectionApp.selectedIds.length, 'two way data binding not working, expected ' + el.data.length + ' but got ' + selectionApp.data.length);
						assert(multi.checked, 'expected the multiselect checkbox to be ticked');

						done();
					});

					test('deselect one at a time', function (done) {
						setupSelection(true, visibleIds);

						var checkboxes = el.$.body.querySelectorAll('paper-checkbox');
						for (var i = 0; i < checkboxes.length; i++)
							checkboxes[i].click();

						var selected = el.$.body.querySelectorAll('paper-checkbox[checked]');
						assert.equal(el.data.length, spy.withArgs('selection-change').callCount, 'selection-change should have been fired ' + el.data.length + 'times');
						assert.equal(0, selected.length, 'expected none of the checkboxes to be checked but found ' + selected.length);
						assert(visibleIds.every(function (e) { return el.selectedIds.indexOf(e) < 0; }), 'expected no ids for visible rows (' + visibleIds + ') to be in selectedIds (' + el.selectedIds + ')');
						assert.equal(0, selectionApp.selectedIds.length, 'two way data binding not working, expected 0 but got ' + selectionApp.data.length);
						assert(!multi.checked, 'expected the multiselect checkbox to be unticked');

						done();
					});
				});

				suite('single selection', function () {
					var checkboxes;

					setup(function () {
						el.select = 'single';
						setupSelection(false, visibleIds);
						checkboxes = el.$.body.querySelectorAll('div.cell.selector paper-checkbox');
					});

					test('select one', function (done) {
						checkboxes[1].click();

						assert.equal(1, el.selectedIds.length, 'expected only one to be selected, not ' + el.selectedIds.length);
						var checked = el.$.body.querySelectorAll('paper-checkbox[checked]').length;
						assert.equal(1, checked, 'expected only one to be selected, not ' + length);
						assert(spy.withArgs('selection-change').calledOnce, 'selection-change should have been fired once')
						done();
					});

					test('deselect one', function (done) {
						el._listenForMultiSelect = false;
						el._listenForSingleSelect = false;

						Polymer.dom(checkboxes[2]).setAttribute('checked', '');
						el.selectedIds = [checkboxes[2].value];

						el._listenForMultiSelect = true;
						el._listenForSingleSelect = true;

						checkboxes[2].click();

						assert.equal(0, el.selectedIds.length, 'expected only one to be selected, not ' + el.selectedIds.length);
						var checked = el.$.body.querySelectorAll('paper-checkbox[checked]').length;
						assert.equal(0, checked, 'expected only one to be selected, not ' + length);
						assert(spy.withArgs('selection-change').calledOnce, 'selection-change should have been fired once')
						done();
					});

					test('select same one', function (done) {
						checkboxes[3].click();
						checkboxes[3].click();

						assert.equal(0, el.selectedIds.length, 'expected only one to be selected, not ' + el.selectedIds.length);
						var checked = el.$.body.querySelectorAll('paper-checkbox[checked]').length;
						assert.equal(0, checked, 'expected only one to be selected, not ' + length);
						assert(spy.withArgs('selection-change').calledTwice, 'selection-change should have been fired twice')
						done();
					});

					test('select a second', function (done) {
						checkboxes[1].click();
						checkboxes[3].click();

						assert.equal(1, el.selectedIds.length, 'expected only one to be selected, not ' + el.selectedIds.length);
						var checked = el.$.body.querySelectorAll('paper-checkbox[checked]').length;
						assert.equal(1, checked, 'expected only one to be selected, not ' + length);
						assert(spy.withArgs('selection-change').calledTwice, 'selection-change should have been fired twice')
						done();
					});
				});
			});
		});
	</script>
</body>

</html>